"use strict";(self.webpackChunkIona_lang=self.webpackChunkIona_lang||[]).push([[542],{5631:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=t(4848),s=t(8453);const o={sidebar_position:5,description:"Functions in Iona"},a="Functions",r={id:"guide/functions",title:"Functions",description:"Functions in Iona",source:"@site/docs/guide/functions.md",sourceDirName:"guide",slug:"/guide/functions",permalink:"/docs/guide/functions",draft:!1,unlisted:!1,editUrl:"https://github.com/broken-bytes/iona-lang/docs/guide/functions.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,description:"Functions in Iona"},sidebar:"tutorialSidebar",previous:{title:"Control flow",permalink:"/docs/guide/control-flow"},next:{title:"Enumerations",permalink:"/docs/guide/enums"}},l={},c=[{value:"Reading functions",id:"reading-functions",level:2},{value:"Mutating functions",id:"mutating-functions",level:2},{value:"Parameters",id:"parameters",level:2}];function u(e){const n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"functions",children:"Functions"}),"\n",(0,i.jsxs)(n.p,{children:["In Iona, there are two different types of functions, ",(0,i.jsx)(n.em,{children:"mutating"})," functions and ",(0,i.jsx)(n.em,{children:"reading"})," functions. By default, every functions is reading, disallowing mutation to its object."]}),"\n",(0,i.jsx)(n.h2,{id:"reading-functions",children:"Reading functions"}),"\n",(0,i.jsxs)(n.p,{children:["Reading functions are only used to calculate values, return properties etc. They cannot alter the state of their object but only ",(0,i.jsx)(n.em,{children:"read"})," it."]}),"\n",(0,i.jsx)(n.p,{children:"A reading function is defined like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:'fn foo() -> String {\n    return ""\n}\n\nprint(foo())\n'})}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsx)(n.p,{children:"Always use reading functions when you don't need to alter state. It makes code more concise and allows understanding side effects more easily."})}),"\n",(0,i.jsx)(n.p,{children:"Functions may have parameters as well, like this:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:'fn foo(bar: String) -> String {\n    return "Foo" + bar\n}\n\nprint(foo(bar: "Bar"))\n'})}),"\n",(0,i.jsx)(n.h2,{id:"mutating-functions",children:"Mutating functions"}),"\n",(0,i.jsx)(n.p,{children:"If the function has a side effect, e.g. it alters the state of its object, the function must be declared at mutating, otherwise the compiler disallows such mutations:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:"var value = 0\n\nmut fn foo() -> Int {\n    value += 1\n    return value\n}\n\n// Prints 1\nprint(foo())\n"})}),"\n",(0,i.jsx)(n.p,{children:"Just like reading functions, mutating functions can have parameters:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:"var value = 0\n\nmut fn foo(newValue: Int) -> Int {\n    value = newValue\n    return value\n}\n\n// Prints 23\nprint(foo(newValue: 23))\n"})}),"\n",(0,i.jsx)(n.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(n.p,{children:"Parameters have some specialities in Iona as well. There are three different ways of passing parameters. By value (value types only), and by reference. Additionally, the mutability of these parameters is also defined in the function signature."}),"\n",(0,i.jsxs)(n.p,{children:["For this, there are two keywords in Iona. ",(0,i.jsx)(n.code,{children:"out"})," and ",(0,i.jsx)(n.code,{children:"mut"}),"."]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"out"})," Allows mutation of an object and the reference, which means that the reference ",(0,i.jsx)(n.em,{children:"and"})," the object it points to may be changed."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"mut"})," Allows only mutation of the object, not the pointer"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"If no modifier is applied, the object may neither change nor the reference to it, resulting in a truly immutable parameter."}),"\n",(0,i.jsxs)(n.p,{children:["An example of a function having a ",(0,i.jsx)(n.code,{children:"mut"})," pointer parameter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:"fn foo(result: mut SomeReferenceType, value1: Int, value2: Int) {\n    // Changes the underlying value of result, not the reference\n    result.value = value1 + value2\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["An example of a function having a ",(0,i.jsx)(n.code,{children:"out"})," pointer parameter:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-Iona",children:"fn foo(result: mut SomeReferenceType, value1: Int, value2: Int) {\n    // Creates a new SomeReferenceType on the heap and assigns its reference to result\n    result = SomeReferenceType()\n    // Assigns the result of value1 + value2 to the underlying memory of result\n    result.value = value1 + value2\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"note",children:(0,i.jsx)(n.p,{children:"In Iona, everything is immutable by default. This prevents unexpected side effects."})})]})}function d(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var i=t(6540);const s={},o=i.createContext(s);function a(e){const n=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(o.Provider,{value:n},e.children)}}}]);