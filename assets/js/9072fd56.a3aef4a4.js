"use strict";(self.webpackChunkIona_lang=self.webpackChunkIona_lang||[]).push([[252],{9581:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>l,metadata:()=>r,toc:()=>d});var i=n(4848),t=n(8453);const l={sidebar_position:1,description:"The three different storage types in Iona"},s="Variables, Mutables, Immutables",r={id:"guide/variables-mutables-immutables",title:"Variables, Mutables, Immutables",description:"The three different storage types in Iona",source:"@site/docs/guide/variables-mutables-immutables.md",sourceDirName:"guide",slug:"/guide/variables-mutables-immutables",permalink:"/docs/guide/variables-mutables-immutables",draft:!1,unlisted:!1,editUrl:"https://github.com/broken-bytes/iona-lang/docs/guide/variables-mutables-immutables.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1,description:"The three different storage types in Iona"},sidebar:"tutorialSidebar",previous:{title:"Guide",permalink:"/docs/category/guide"},next:{title:"Builtin Types",permalink:"/docs/guide/builtins"}},o={},d=[{value:"The right level of immutability",id:"the-right-level-of-immutability",level:2},{value:"Variables",id:"variables",level:3},{value:"Mutables",id:"mutables",level:3},{value:"Immutables",id:"immutables",level:3},{value:"Why a third level?",id:"why-a-third-level",level:2},{value:"Declaring variables",id:"declaring-variables",level:2},{value:"Type-inference",id:"type-inference",level:2},{value:"Optionals",id:"optionals",level:2},{value:"Optional unwrapping",id:"optional-unwrapping",level:3}];function h(e){const a={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(a.h1,{id:"variables-mutables-immutables",children:"Variables, Mutables, Immutables"}),"\n",(0,i.jsxs)(a.p,{children:["Iona provides ",(0,i.jsx)(a.em,{children:"variables"})," that allow developers to store values in a named storage. There are three different types of ",(0,i.jsx)(a.em,{children:"variables"})," in Iona.\nVariables (fully mutable), Mutables (partially mutable), and Immutables (immutable)."]}),"\n",(0,i.jsx)(a.p,{children:"Every variable has a fixed type that cannot be changed after declaration in Iona.\nThis way, the best possible type-safety is ensured, leaving no room for type or implicit conversion errors."}),"\n",(0,i.jsx)(a.h2,{id:"the-right-level-of-immutability",children:"The right level of immutability"}),"\n",(0,i.jsx)(a.p,{children:"Iona has a different approach on variables as seen in other languages. Instead of providing mutable and immutable(not really) storage types, it offers three different levels of immutability."}),"\n",(0,i.jsx)(a.p,{children:"This way, the meaning and behaviour of each piece of code is clearly readable without having to scim through all the surrounding blocks of code."}),"\n",(0,i.jsx)(a.h3,{id:"variables",children:"Variables"}),"\n",(0,i.jsxs)(a.p,{children:["Variables in Iona are defined via ",(0,i.jsx)(a.code,{children:"var"}),". They behave like variables in every language. Both the reference and the value can be changed. For pointers this means the pointer can be changed, and the memory it points to."]}),"\n",(0,i.jsx)(a.h3,{id:"mutables",children:"Mutables"}),"\n",(0,i.jsxs)(a.p,{children:["Mutables are defined via ",(0,i.jsx)(a.code,{children:"val"}),". Mutables are one level less mutable than variables. Instead of allowing change to the reference or pointer, they only allow changes to the underlying value or memory.\nThis is the same behaviour like found in languages like Kotlin (",(0,i.jsx)(a.code,{children:"val"}),") or Swift (",(0,i.jsx)(a.code,{children:"let"}),")."]}),"\n",(0,i.jsx)(a.h3,{id:"immutables",children:"Immutables"}),"\n",(0,i.jsxs)(a.p,{children:["Immutables are defined via ",(0,i.jsx)(a.code,{children:"let"}),". Unlike in most other modern languages, Iona offers a third level of immutability. Immutables neither allow changes to the object, nor to the reference. They are truly immutable references."]}),"\n",(0,i.jsx)(a.h2,{id:"why-a-third-level",children:"Why a third level?"}),"\n",(0,i.jsx)(a.p,{children:"Many languages mitigate the issue of truly immutable objects by using a constant object that itself only has constant properties. While this is a suitable way of doing it, it comes with drawbacks:"}),"\n",(0,i.jsxs)(a.ul,{children:["\n",(0,i.jsx)(a.li,{children:"The object is immutable for every part of the code except where its constructor is called."}),"\n",(0,i.jsx)(a.li,{children:"It's impossible to change the object's properties at one part of the code and let other parts listen to it."}),"\n",(0,i.jsx)(a.li,{children:"True immutability is subject to conventions within the codebase - thus objects can become mutable any time if a developer adds at least one mutable property."}),"\n"]}),"\n",(0,i.jsx)(a.p,{children:"These drawbacks lead to the decision to incorparate a third level of immutability."}),"\n",(0,i.jsx)(a.admonition,{type:"note",children:(0,i.jsxs)(a.p,{children:["Immutables are only immutable on the ",(0,i.jsx)(a.code,{children:"let"})," reference. There can be other, mutable references to the same object.\nImmutables only guarantee that the object cannot get mutated from that very reference."]})}),"\n",(0,i.jsx)(a.h2,{id:"declaring-variables",children:"Declaring variables"}),"\n",(0,i.jsx)(a.p,{children:"The three different storage types are declared like this:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-Iona",children:"// A variable\nvar data: Int = 3\n// A mutable\nval data: Int = 3\n// An immutable\nlet data: Int = 3\n"})}),"\n",(0,i.jsxs)(a.p,{children:["If there are multiple branches like a ",(0,i.jsx)(a.code,{children:"when"})," or ",(0,i.jsx)(a.code,{children:"if/else"}),", the variable may be declared at top but only defined in each branch:"]}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-Iona",children:"var data: Int\nif someValue {\n    data = 3\n} else {\n    data = 2\n}\n"})}),"\n",(0,i.jsx)(a.admonition,{type:"note",children:(0,i.jsxs)(a.p,{children:["Iona does ",(0,i.jsx)(a.strong,{children:"not"})," not allow defining multiple variables in a single line like this: var x = 0, y = 1, z = 2."]})}),"\n",(0,i.jsx)(a.h2,{id:"type-inference",children:"Type-inference"}),"\n",(0,i.jsxs)(a.p,{children:["Iona also comes with a powerful feature called ",(0,i.jsx)(a.em,{children:"type-inference"}),".\nType-inference allows developers to omit the type from the variable declaration as long as the variable declaration includes an assignment. This assignment is evaluated at compile time to get the correct type."]}),"\n",(0,i.jsx)(a.p,{children:"If the variable shall not have an assignment immediately, the type must be defined. Every variable needs a value, otherwise the compiler will issue an error. This is to enforce memory safety by default, disallowing empty variables or unassigned memory."}),"\n",(0,i.jsx)(a.p,{children:"This is what type inference looks like:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-Iona",children:"// Inferred to be Int because `3` is an integer literal\nvar data = 3\n"})}),"\n",(0,i.jsx)(a.h2,{id:"optionals",children:"Optionals"}),"\n",(0,i.jsxs)(a.p,{children:["If variables should be allowed to be empty or uninitialised, they can be declared ",(0,i.jsx)(a.em,{children:"optional"}),".\nOptionals are wrappers over regular variables, just that they allow them to ",(0,i.jsx)(a.strong,{children:"not"})," have a value. Optionals are defined by appending ",(0,i.jsx)(a.code,{children:"?"})," to the type.\nOptionals are the only types that allow ",(0,i.jsx)(a.code,{children:"none"}),"."]}),"\n",(0,i.jsx)(a.admonition,{type:"note",children:(0,i.jsxs)(a.p,{children:["Only variables (",(0,i.jsx)(a.code,{children:"var"}),") can be declared optionals. This is to ensure that the reference may be changed, so that the variable does hold a value at a later stage."]})}),"\n",(0,i.jsxs)(a.p,{children:["When an optional has ",(0,i.jsx)(a.em,{children:"no"})," value, it holds a special value called ",(0,i.jsx)(a.code,{children:"none"}),"."]}),"\n",(0,i.jsx)(a.p,{children:"This is how to declare optionals:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-Iona",children:"var data: Int? = .none\ndata = 3\n"})}),"\n",(0,i.jsx)(a.h3,{id:"optional-unwrapping",children:"Optional unwrapping"}),"\n",(0,i.jsxs)(a.p,{children:["Optionals need unwrapping before their values can be used. Unwrapping an optional is done by either using ",(0,i.jsx)(a.code,{children:"?"})," (safe unwrapping) or ",(0,i.jsx)(a.code,{children:"!"})," (force unwrapping).\nSafe unwrapping only executes the code when the optional is not ",(0,i.jsx)(a.code,{children:"none"}),", resuling in safer code. ",(0,i.jsx)(a.code,{children:"!"})," should only be used when it is certain that the optional holds a value. ",(0,i.jsx)(a.code,{children:"!"})," skips runtime checks ensuring increased performance but comes at the cost of possible memory read errors, leading to crashes that aren't catchable."]}),"\n",(0,i.jsx)(a.p,{children:"This is what unwrapping looks like:"}),"\n",(0,i.jsx)(a.pre,{children:(0,i.jsx)(a.code,{className:"language-Iona",children:"// Empty value variable\nvar value: Int? = .none\n// Assign to a new variable (value2), use a default value if value is `none`\nvar value2 = value? ?? 2\n// Skip safety checks, unwrap the optional and assign it to the other variable\n// In this setup, this would crash as value is `none`\nvar value3 = value!\n"})}),"\n",(0,i.jsxs)(a.admonition,{type:"danger",children:[(0,i.jsxs)(a.p,{children:["Force-unwrapping should only be done when it can be made 100% sure that the optional is not ",(0,i.jsx)(a.code,{children:"none"}),". Force-unwrapping an empty optional crashes the application as it results in a ",(0,i.jsx)(a.code,{children:"panic"}),"."]}),(0,i.jsxs)(a.p,{children:["There is ",(0,i.jsx)(a.strong,{children:"no"})," way to prevent such crashes."]})]})]})}function c(e={}){const{wrapper:a}={...(0,t.R)(),...e.components};return a?(0,i.jsx)(a,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},8453:(e,a,n)=>{n.d(a,{R:()=>s,x:()=>r});var i=n(6540);const t={},l=i.createContext(t);function s(e){const a=i.useContext(l);return i.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function r(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(l.Provider,{value:a},e.children)}}}]);